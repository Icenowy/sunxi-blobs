






; goto start


; goto hang


; goto hang


; goto hang


; goto hang


; goto hang


; goto fel_irq_handler


; goto hang


; goto fel_start


; hang: for (;;) /* SPIN */
















; goto egon_header; // (*0x170 == 0x2c00)




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































; _start: goto start2
; _start_alt: goto start2_alt




; _start2: goto unknown_affinity
; _start2_alt: goto boot_to_fel
; unknown_affinity: u32 boot_magic = 0
; goto get_affinity
; boot_to_fel: u32 boot_magic = BOOT_TO_FEL
; goto cpu0only
; cpu0plus: void **soft_entry_address = *(void ***)0x00002e54; // = 0x01f01da4
; goto **soft_entry_address
; get_affinity: u32 mpidr = read_mpidr()
; u32 aff0 = mpidr & 0x00000003
; if (aff0 != 0)
;       goto cpu0plus
; u32 aff1 = mpidr & 0x0000ff00
; if (aff1 != 0)
;       goto cpu0plus
; u32 *hot_plug_mode_ptr = *(u32 **)0x00002e58; //  = 0x01f01dac
; u32 hot_plug_magic = *(u32 *)0x00002e5c;      //  = 0xfa50392f
; u32 hot_plug_mode = *hot_plug_mode_ptr
; if (hot_plug_mode != hot_plug_magic)
;       goto cpu0only
; goto cpu0plus; // hot_plug_entry_address is soft_entry_address


; cpu0only: r0 = 0x00000002
; debug_checkpoint_data(2)
; u32 i = 0x00000050
; while (--i != 0)
;       /* spin */
; u32 cpsr = read_cpsr()
; cpsr &= ~0x0000001f;                          // clear execution mode
; cpsr |= 0x00000013;                           // execution mode = SVC
; cpsr |= 0x000000c0;                           // disable interrupts
; cpsr &= ~0x00000200;                          // set little endianness
; write_cpsr(cpsr)
; read from CoProcessor
; MMU disabled, data caching disabled
; program flow prediction disabled, instruction caching disabled
; write to CoProcessor
; u32 *wdt_mode_ptr = *(u32 **)0x00002e60;      //  = 0x01c20cb8
; u32 wdt_mode = *wdt_mode_ptr
; wdt_mode &= ~WDOG0_EN
; *wdt_mode_ptr = wdt_mode
; u32 *pll_cpux_ptr = *(u32 **)0x00002e64;      //  = 01c20000
; START CLOCK SETUP ^^

















; ^^ CLOCK SETUP THINGS vv














; END CLOCK SETUP
; set up stack to start at 0x00017ffc
; ptr to SS_MAGIC CPUCFG register
; read cpucfg

; get bottom word of cpucfg in r0
; magic value in r1
; if it matches...
; resume_from_suspend();                             // does not return
; otherwise... busy loop 2000 times:
; while (--r0)
;       /* spin */
; set sp to 0x00048000 (in SRAM A2)
; u32 *bus_rst_reg_ptr = *(u32 **)0x00002e74;   // = 0x01c202c4
; u32 bus_rst_reg = *bus_rst_reg_ptr

; bus_rst_reg |= 1;                             // de-assert VE_RST
; *bus_rst_reg_ptr = bus_rst_reg
; u32 *bus_clk_reg_ptr = *(u32 **)0x00002e78;   // = 0x01c20064
; u32 bus_clk_reg = *bus_clk_reg_ptr

; bus_clk_reg |= 1;                             // unmask VE_GATING
; *bus_clk_reg_ptr = bus_clk_reg
; SRAM_CTL0_CFG SYSCON register
; u32 sram_ctl = *sram_ctl_ptr
; move pages  0- 7 to CPU control
; move pages  8-15 to CPU control
; move pages 16-23 to CPU control
; move pages 24-30 to CPU control
; *sram_ctl_ptr = sram_ctl
; sram_ctl_ptr = *(u32 **)0x00002e7c;           // = 0x01c00004

; sram_ctl = 0x01000001
; *sram_ctl_ptr = sram_ctl
; if (boot_magic == BOOT_TO_FEL)
;       run_fel_mode()

; boot(111)
; for (;;) /* SPIN */

; void debug_checkpoint_data(u32 iter)
;   u32 *ptr = *(u32 **)0x00002e80;             // = 0x01c000a4
;   u32 data = *ptr
;   u32 mask = 0x00000001
;   data |= mask;                               // set bit 0
;   *ptr = data
;   do { ptr = *(u32 **)0x00002e80;             // = 0x01c000a4
;       mask = 0x00000002
;       data = *ptr
;       data &= ~mask;                          // clear bit 1
;       *ptr = data
;       data = *ptr
;       data |= mask;                           // set bit 1
;       *ptr = data
;       u32 cycles = 0x00000003
;       while (--cycles != 0)
;               /* spin */
;       data = *ptr
;       data &= ~mask;                          // clear bit 1
;       *ptr = data

;   } while (--iter != 0)
;   ptr = *(u32 **)0x00002e80;                  // = 0x01c000a4
;   data = *ptr
;   mask = 0x00000001
;   data &= ~mask;                              // clear bit 0
;   *ptr = data
;   return



; void debug_checkpoint_address(u32 param0)



; r1 = 0x80000 + (arg0 << 8)
; r2 = *r1
;   return

; void enable_jtag(void)
;   r0 = 0;                                     // effectively a NOP
;   u32 *ptr = *(u32 **)0x0000307c;             // = 0x01c208b4
;   u32 data = *ptr1;                           // read PF_CFG0_REG
;   u32 mask = *(u32 *)0x00003080;              // = 0xff888888
;   data &= mask;                               // clear port F functions
;   mask = *(u32 *)0x00003084;                  // = 0x07373733
;   data |= mask;                               // set port F to JTAG function
;   *ptr1 = data;                               // write PF_CFG0_REG
;   return

; void run_sram_image(void *address, u32 param1)
;   // nop
;   void *saved_address = address
;   // nop, so param1 not used

;   debug_checkpoint_data(7)
;   address = saved_address
;   jump_to(address)
;   // does not return

; void run_fel_mode(void)
;   // nop
;   enable_jtag()

;   debug_checkpoint_data(8)

;   jump_to(__fel)
;   // does not return

; void boot(u32 magic)
;   // nop
;   u32 saved_magic = magic
;   // nop
;   read_and_save_lcjs()
;   if (saved_magic == 0)
;       goto normal_boot
;   u32 ret = check_uboot()
;   u32 uboot = ret
;   if (uboot == 0)
;       goto normal_boot
;   goto fel_boot
;   normal_boot:
;   debug_checkpoint_address(0)

;   debug_checkpoint_data(3)

;   ret = load_from_sdc(0)
;   u32 cond = ret
;   if (cond != 0)
;       goto try_load_emmc2
;   goto load_success
;   try_load_emmc2:
;   debug_checkpoint_address(1)

;   debug_checkpoint_data(5)

;   ret = func_5000(2)
;   cond = ret
;   if (cond != 0)
;       goto try_load_sdc2
;   goto load_success
;   try_load_sdc2:
;   debug_checkpoint_address(2)

;   ret = load_from_sdc(2)
;   cond = ret
;   if (cond != 0)
;       goto try_load_nand
;   goto load_success
;   try_load_nand:
;   debug_checkpoint_address(3)

;   debug_checkpoint_data(4)
;   ret = func_4d28()
;   cond = ret
;   if (cond != 0)
;       goto try_load_spi
;   goto load_success
;   try_load_spi:
;   debug_checkpoint_address(4)

;   debug_checkpoint_data(6)
;   ret = func_74e8()
;   cond = ret
;   if (cond != 0)
;       goto load_failure
;   goto load_success
;   load_failure:
;   debug_checkpoint_address(5)

;   fel_boot: run_fel_mode();                 // does not return

;   load_success:

;   boot_loaded_image(0x10000, 0xfc);           // does not return
;   // does not return

; void resume_from_suspend(void)

;   void **image_reg = *(void ***)0x00003088;   // = 0x01f01da8
;   void *image = 0
;   u32 len = 0
;   image = *image_reg;                         // img header from reg
;   len = *(image + 16);                        // img len from header
;   char *egon_bt0 = 0x3024+0x68;               // = 0x0000308c

;   ret = verify_header_magic(*image_reg, egon_bt0)
;   if (ret != 0)
;       goto resume_failure
;   ret = len
;   ret &= 0x000003ff;                          // check kb alignment
;   if (ret != 0)
;       goto resume_failure


;   ret = verify_header_checksum(*image_reg, len)
;   if (ret != 0)
;       goto resume_failure

;   debug_checkpoint_data(9)


;   boot_loaded_image(*image_reg, 0xfc);        // does not return
;   resume_failure:
;   debug_checkpoint_data(10)

;   boot(0);                            // does not return




; void write_efuse(u32 index, u32 data)




























; u32 read_efuse(u32 index)
;   u32 saved_index = index
;   u32 data = 0
;   u32 ret = 0













;   // nop
;   do { ptr = *(u32 **)0x00003224;             // = 0x01c14000
;       data = *(ptr + 0x40);                   // read SID_PRCTL
;       data &= 0x02;                           // keep only SID_PRCTL_READ

;   } while (data != 0);                        // wait for read to finish
;   mask = *(u32 **)0x0000322c;                 // = 0xfe0000fc
;   data &= mask
;   ptr = *(u32 **)0x00003224;                  // = 0x01c14000
;   *(ptr + 0x40) = data
;   ret = *(ptr + 0x60);                        // get eFUSE from SID_RDKEY
;   return

; void read_and_save_lcjs(void)

;   u32 tmp = 0

;   u32 data = read_efuse(0xf4)
;   tmp = data
;   data = tmp >> 16
;   u32 *ptr = *(u32 **)0x00003230;             // = 0x00053f00
;   *ptr = data
;   return

; u32 lcjs_get_dma_wait(void)




















; u32 lcjs_get_ce_clksrc(void)




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































; void load_from_sdcard(u32 controller)































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































; // = 0x1c68000, SPI0_BASE_REG











































































































































































































































































































































; u32 verify_header_magic(char *image, char *egon_bt0)

;   char *tmp1 = image
;   char *tmp2 = tmp1
;   char *magic = tmp2 + 4;                     // skip image entry jump
;   u32 i = 0
;   u32 len = 8;                                // length of "eGON.BT0"
;   while (i < len)
;       char a = *magic++
;       char b = *egon_bt0++
;       if (a == b)
;           goto next:
;       retval = 1
;       out: return
;       next: i++


;   retval = 0
;   goto out

; u32 verify_header_checksum(char *image, u32 len)



























































; u32 udelay(s32 cycles)
;   // nop
;   // nop
;   while (cycles > 0)
;       cycles--


;   return

; u32 check_uboot(void)

;   u32 ret = 0
;   u32 delay = 60
;   s32 iter = 4
;   while (iter > 0)

;       udelay(delay)
;       u32 syscon = 0x1c00000
;       u32 uboot = *(u32 *)(syscon + 0x24)
;       uboot = (uboot & (1 << 8)) >> 8
;       ret += uboot
;       iter--


;   if (ret != 0)
;       goto success
;   retval = -1
;   out: return retval
;   success: retval = 0
;   goto out


































; void jump_to(void *address)
;   goto *address
