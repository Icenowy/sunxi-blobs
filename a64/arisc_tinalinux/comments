














































































; int cpucfg_set_power_switch(int enable);


; if (enable != 0) {



;     ptr = 0x01f01540 [R_PRCM_PWR_CLAMP_REG(0, 0)]
;     reg = *ptr
;     if (reg == 0) {


;         level = 2
;         msg = 0x00010960 "cpu%d power switch enable already"
;         goto print
;     }
;     reg = 0xfe
;     *ptr = reg
;     timer_udelay(20)

;     reg = 0xf8
;     *ptr = reg
;     timer_udelay(10)

;     reg = 0xe0
;     *ptr = reg
;     timer_udelay(10)

;     reg = 0xc0
;     *ptr = reg
;     timer_udelay(10)

;     reg = 0x80
;     *ptr = reg
;     timer_udelay(10)

;     reg = 0x0
;     *ptr = reg
;     timer_udelay(20)

;     while (*ptr != 0x0)
;         /* spin */



; } else {

;     ptr = 0x01f01540 [R_PRCM_PWR_CLAMP_REG(0, 0)]
;     reg = *ptr
;     if (reg == 0xff) {



;         msg = 0x00010983 "cpu%d power switch disable already"
;         level = 2
; print:  printf(level, msg, <missingno>)


;     } else {
;         reg = 0xff
;         *ptr = reg
;         timer_udelay(30)

;         while (*ptr != 0xff)
;             /* spin */

;     }
; }
; ret = 0

; return ret





; ptr3 = 0x00012260
; var2 = 0

; *ptr3 = var2

; ret = var2
; return ret





; ptr3 = 0x00012260
; var2 = 0

; *ptr3 = var2

; ret = var2
; return ret


; int cpucfg_set_ss_flag(void);


; ptr = 0x01f01da0 [R_CPUCFG_SS_FLAG_REG]
; flag = 0x16aaefe8
; ret = 0
; *ptr = flag

; flag = 0xaa16efe8
; *ptr = flag
; return ret


; int cpucfg_clear_ss_flag(void);

; flag = 0x16aa0000
; ptr = 0x01f01da0 [R_CPUCFG_SS_FLAG_REG]
; ret = 0
; *ptr = flag
; flag = 0xaa160000
; *ptr = flag
; return ret


; u32 cpucfg_get_status(u32 mpidr);
; mpidr >>= 2

; if (mpidr != 0)

;     ptr = 0x01700034 [CPUCFG_CPU_STS_REG(1)]
; else
;     ptr = 0x01700030 [CPUCFG_CPU_STS_REG(0)]
; ret = *ptr
; return ret














; msg = 0x000109a7 "no space for little-endian config"

































; int cpucfg_set_cpu_state(u32 cpu, int flag);
; cluster = cpu >> 2


; flag &= BIT(0) // 0 = assert, 1 = deassert
; if (cluster != 0) {

;     cpu -= 4
;     ptr = 0x01700084 [CPUCFG_RST_CTRL_REG(1)]
;     reg = *ptr
;     orig = reg

; } else {


;     ptr = 0x01700080 [CPUCFG_RST_CTRL_REG(0)]
;     reg = *ptr
;     orig = reg
; }

; ret = 0
; reg = BIT(cpu)
; new = flag << cpu
; mask = ~reg
; reg = mask & orig


; new |= reg


; *ptr = new
; return ret


; void cnt64_clear(void);


; ptr = 0x01f01e80 [CNT64_CTRL_REG]
; ret = 0
; reg = *ptr


; reg |= BIT(0)


; *ptr = reg
; return ret


; unsigned long long cnt64_read(void);


; ptr = 0x01f01e80 [CNT64_CTRL_REG]
; reg = *ptr


; reg |= BIT(1)


; *ptr = reg
; while (*ptr & BIT(1) != 0)
;     /* spin */



; loptr = 0x01f01e84 [CNT64_LOW_REG]
; hiptr = 0x01f01e88 [CNT64_HIGH_REG]
; loreg = *loptr

; hireg = *hiptr

; ret = hireg
; ret_hi = loreg
; return (unsigned long long) (ret_hi, ret)


; int cpucfg_set_ss_entry(u32 addr);

; ret = 0
; ptr = 0x01f01da8 [R_CPUCFG_SS_ENTRY_REG]
; *ptr = addr
; return ret


; void cpucfg_set_acinactm(u32 val);


; ptr = 0x01700004 [CPUCFG_CLS_CTRL_REG1(0)]

; reg = *ptr
; mask = ~BIT(0)

; val &= BIT(0)

; reg &= mask


; val |= reg


; *ptr = val

; return


; void cpucfg_wait_cluster_idle(void);

; ptr = 0x01700030 [CPUCFG_CPU_STS_REG(0)]
; do {var4 = *ptr
;     var4 &= BIT(0)
; } while (var4 == 0)


; return


; void cpucfg_set_l2rstdisable(u32 val);
; ptr = 0x01700000 [CPUCFG_CLS_CTRL_REG0(0)]

; reg = *ptr

; mask = 0xffffffe0

; val &= 0x0000001f

; reg &= mask


; val |= reg


; *ptr = val

; return


; void cpucfg_set_cluster_state(int enable);


; if (flag != 0)


;     if (flag != 1)
;         goto err



; if (enable == 0) {

;     ptr = 0x01700080 [CPUCFG_RST_CTRL_REG(0)]
;     mask = 0xfff0ffff
;     reg = *ptr


;     reg &= mask // assert undocumented reset


;     mask = 0xff0fffff

;     *ptr = reg
;     reg = *ptr


;     reg &= mask // assert MBIST_RST
;     m2 = 0xfffffff0


;     *ptr = reg

;     p2 = 0x01f01c30 [R_CPUCFG_PONRESET_REG(0)]
;     r2 = *p2


;     r2 &= m2 // assert cpu0-3 PONRESET


;     mask = ~BIT(24)

;     *p2 = r2
;     reg = *ptr // back to changing 0x01700080


;     reg &= mask // assert SOC_DBG_RST
;     mask = ~BIT(8)


;     *ptr = reg
;     reg = *ptr


;     reg &= mask // assert L2_RST
;     mask = ~BIT(12)


;     *ptr = reg
;     reg = *ptr


; DS  reg &= mask // assert HRESET
; } else {
;     mask = BIT(24)
;     ptr = 0x01700080 [CPUCFG_RST_CTRL_REG(0)]
;     reg = *ptr


;     reg |= BIT(12) // deassert HRESET


;     *ptr = reg
;     reg = *ptr


;     reg |= BIT(8) // deassert L2_RST


;     *ptr = reg
;     reg = *ptr


;     reg |= mask // deassert SOC_DBG_RST
;     mask = 0x00f00000


;     *ptr = reg

;     p2 = 0x01f01c30 [R_CPUCFG_PONRESET_REG(0)]
;     r2 = *p2


;     r2 |= BIT(0) // deassert cpu0 PONRESET


;     *p2 = r2
;     reg = *ptr // back to changing 0x01700080


;     reg |= mask // deassert MBIST_RST
;     mask = 0x000f0000


;     *ptr = reg
;     reg = *ptr


;     reg |= mask // deassert undocumented reset
; }

; *ptr = reg


; return

; err:

; msg = 0x000109ca "invalid cluster reset status"

; return printf(2, msg);


; void cpucfg_suspend_cluster(void);





; cpucfg_set_cpu_state(0, 0) // assert cpu0
; mask = ~BIT(0)

; ptr = 0x01f01c30 [R_CPUCFG_PONRESET_REG(0)]
; reg = *ptr


; reg &= mask // assert cpu0 PONRESET


; *ptr = reg
; cpucfg_set_acinactm(1) // disable snooping

; rtc_set_pwrstate(0x0000b000)

; cpucfg_wait_cluster_idle()

; rtc_set_pwrstate(0x0000b001)


; cpucfg_set_cpu_state(0, 0) // assert cpu0


; cpucfg_set_cpu_state(1, 0) // assert cpu1


; cpucfg_set_cpu_state(2, 0) // assert cpu2


; cpucfg_set_cpu_state(3, 0) // assert cpu3




; return rtc_set_pwrstate(0x0000b002)


; int cpucfg_disable_cluster(void);


; cpucfg_set_cluster_state(0)

; rtc_set_pwrstate(0x0000b003)


; cpucfg_func_00009c00(5, 1)


; cpucfg_func_00009c00(4, 1)

; rtc_set_pwrstate(0x0000b004)

; cpucfg_set_power_switch(0)



; return rtc_set_pwrstate(0x0000b005)


; int cpucfg_enable_cluster(void);


; cpucfg_set_power_switch(1)

; rtc_set_pwrstate(0x0000b006)


; cpucfg_func_00009c00(5, 0)


; cpucfg_func_00009c00(4, 0)

; rtc_set_pwrstate(0x0000b007)

; cpucfg_set_acinactm(0) // enable snooping

; rtc_set_pwrstate(0x0000b00a)


; cpucfg_set_cpu_state(0, 0) // assert cpu0

; rtc_set_pwrstate(0x0000b008)

; cpucfg_set_cluster_state(1)

; rtc_set_pwrstate(0x0000b009)



; return 0


; int cpucfg_resume_cpu0(void *entry);




; cpucfg_set_l2rstdisable(0)

; rtc_set_pwrstate(0x0000b00b)



; ptr = 0x01f01da8 [R_CPUCFG_SS_ENTRY_REG]
; *ptr = entry
; rtc_set_pwrstate(0x0000b00c)


; cpucfg_set_cpu_state(0, 3) // deassert cpu0

; rtc_set_pwrstate(0x0000b00d)


; ret = 0

; return ret
































































































































































































































































; msg = 0x000109e8 "dram standby code version 1.6"




























































































































































































































































































































































































































































































































































































































































































































































































































































































































; msg = 0x00010a07 "DRAM training error,PGSR0 = %x"









































































; msg = 0x00010a27 "dram data write back start..."































; msg = 0x00010a47 "dram data write back end."













































































































; return rtc_set_pwrstate(0x00009007)













; return rtc_set_pwrstate(0x00009007)






































































; msg = 0x00010a63 "msgbox irq coming..."

































; msg = 0x00010a79 "inv msg[%x] rec"











































; msg = 0x00010a79 "inv msg[%x] rec"





































































































































; msg = 0x00010a8a "send syn message : %x"






















; msg = 0x00010aa1 "hsyn msg err"





; msg = 0x00010aaf "hsyn msg[%x, %x] fb"

















; msg = 0x00010ac4 "send asyn or soft syn message : %x"



















; msg = 0x00010ae8 "message : %x finished"






































; msg = 0x00010aff "feedback hard syn message : %x"





























; msg = 0x00010ac4 "send asyn or soft syn message : %x"





































































; msg = 0x00010b1f "inv msg rec"




























































































; msg = 0x00010b2c "take hwspinlock%d timeout"






























































































































; msg = 0x00010b47 "clean NMI interrupt pending"
















; msg = 0x00010b64 "intno:%d interrupt enable"
































; msg = 0x00010b7f "irq [%x] enable before ISR install"





















































; int register_isr(u32 index, u32 isr, u32 arg2);









; msg = 0x00010ba3 "install isr %x"

; printf(1, msg, arg2)

; offset = index << 3

; ret = 0
; base = 0x000123b0
; ptr = offset + base
; *ptr = isr
; *(ptr + 4) = arg2




; return ret


; int unregister_isr(u32 index, u32 isr);


; offset = index << 3
; base = 0x000123b0

; ptr = offset + base
; old = *ptr
; if (old == isr)



;     zero = 0
;     new = 0x000068a8
;     *(ptr + 4) = zero
;     *ptr = new
;     return 0



; printf(4, msg)
; msg = 0x00010bb3 "ISR not installed!"
; ret = -1


; return ret






































































































; msg = 0x00010bc7 "ir data full"











































































































































































; msg = 0x00010bd5 "ir key:%x, addr:%x"




























; msg = 0x00010be9 "read ir fifo raw data failed"



















; msg = 0x00010be9 "read ir fifo raw data failed"










































; msg = 0x00010c07 "lead1"







































; msg = 0x00010c0e "lead0"





















; msg = 0x00010c15 "Pulse %d"















; msg = 0x00010c1f "Distant %d"






















; msg = 0x00010c2b "%2x"


















































; msg = 0x00010c30 "detect valid ir code :%x"





; msg = 0x00010c4a "detect ir raw code :%x"



























; msg = 0x00010c62 "ir rx fifo full"






; msg = 0x00010c73 "inv ir rx irq det, st:0x%x"

























































































































































































































































































































































































































































































































































































; msg = 0x00010c8f "invalid power voltage type[%u]"




















































































; msg = 0x00010c8f "invalid power voltage type[%u]"































; msg = 0x00010caf "invalid voltage value[%u] to set, type[%u], the reasonable range[%u-%u]"



























































































































































































; msg = 0x00010cf8 "NMI irq coming..."








; msg = 0x00010d0b "invalid nmi int type"












; msg = 0x00010d21 "allocate message for nmi int notify failed"





















































































; msg = 0x00010d4d "query pmu wakeup event"








; msg = 0x00010d65 "vbus"











; msg = 0x00010d6b "acin"











; msg = 0x00010d71 "battary full"












; msg = 0x00010d7f "bat temp"












; msg = 0x00010d89 "low battary"











; msg = 0x00010d96 "GPIO0 input edge"












; msg = 0x00010da8 "GPIO1 input edge"












; msg = 0x00010dba "long key"












; msg = 0x00010dc4 "short key"












; msg = 0x00010dcf "POK negative"











; msg = 0x00010ddd "POK postive"






; msg = 0x00010dea "event:%x"



























































; msg = 0x00010df4 "AW1660 IC_NO_REG value = %x"











































































































































































































































; msg = 0x00010e11 "cfg pmu charge temp:%d, max_cur:%d"



















; msg = 0x00010e35 "cfg pmu temp safe range:0x%x ~ 0x%x"




























; msg = 0x00010e5a "bat_charge_temp:%d"


























; msg = 0x00010e6e "curr_set_ma:%d"




















; msg = 0x00010e7e "rel_curr_ma:%d"













; msg = 0x00010e8e "quan_c:%d"




































; msg = 0x00010e99 "temp_c:%d"














































; msg = 0x00010ea4 "adjust:%d"





; msg = 0x00010eaf "set cur:%x"

























































; msg = 0x00010ebb "mv:%x"


























; msg = 0x00010ec2 "mac:%x"






















; msg = 0x00010eca "mab:%x"



































; msg = 0x00010ed2 "power wakeup axp main reg10:%x"



















; msg = 0x00010ef2 "power wakeup axp main reg12:%x"





















; msg = 0x00010f12 "power wakeup axp main reg13:%x"





























; msg = 0x00010f32 "power wakeup axp main reg90:%x"




























; msg = 0x00010f52 "power wakeup axp main reg92:%x"




















































































; void rtc_set_pwrstate(u32 val);

; ptr = 0x01f0010c [R_RTC_GP_DATA_REG(3)]
; *ptr = val
; return


; u32 rtc_get_pwrstate(void);

; ptr = 0x01f0010c [R_RTC_GP_DATA_REG(3)]
; ret = *ptr
; return ret






































































; msg = 0x00010f72 "invaid module clock id (%d) when set source"












































; msg = 0x00010f9f "icd %x"














































































































; msg = 0x00010fa7 "invaid module clock id (%d) when set divider"























































































; msg = 0x00010fd5 "invaid module clock id (%d) when get divider"




































































































































; msg = 0x00010fa7 "invaid module clock id (%d) when set divider"




























































; msg = 0x00011003 "broadcast apb clock will change"




























; msg = 0x00011024 "broadcast apb clock change done"








































































































































































































































































































; msg = 0x00011045 "invaid power control module (%d) when set power-off gating"
























; msg = 0x00011081 "broadcast 24mhosc will power-off"








































































; msg = 0x000110a3 "broadcast 24mhosc power-on ready"

















































































































; msg = 0x000110c5 "invaid module clock id (%d) when set reset"

































































































































; msg = 0x000110f1 "PLL1 Freq %d N %d K %d M %d P %d"







; msg = 0x00011113 "invaid clock id (%d) when set freq"



















































































































; msg = 0x00011137 "invalid clock id for get source freq"


























; msg = 0x0001115d "rsb clk change request"

















; msg = 0x00011175 "rsb clk change done"




































; ptr3 = 0x01f0340c [R_RSB_STAT]

; var2 = *ptr3






; msg = 0x0001118a "loading busy"









; msg = 0x00011198 "rsb trans err[%x]"









































; msg = 0x000111ab "set rtsaddr failed, saddr:%x, rtsaddr:%x"









































; msg = 0x000111d5 "rsb set pmu mode failed"





































































; msg = 0x000111ee "write devaddr:%x, regaddr:%x, data:%x, datatype:%x"





















; msg = 0x00011222 "err datatype %d"


































; msg = 0x00011233 "rsb write failed"





; msg = 0x000111ee "write devaddr:%x, regaddr:%x, data:%x, datatype:%x"
















































; msg = 0x00011222 "err datatype %d"









; msg = 0x00011245 "data=0"






























; msg = 0x0001124d "rsb read failed"



; msg = 0x0001125e "read devaddr:%x, regaddr:%x, data:%x, datatype:%x"


























; msg = 0x0001125e "read devaddr:%x, regaddr:%x, data:%x, datatype:%x"





































































































































































































































































; msg = 0x00011291 "24m hosc will power-off notify"


































; msg = 0x000112b1 "24m hosc power-on ready notify"




























































; msg = 0x000112d1 "timer irq handler not install"
































































































































; msg = 0x000112f0 "no free timer now"










































































































































































; void timer_udelay(u32 usecs);




; if (usecs == 0)
;     return

; (time_hi, time_lo) = cnt64_read()
; end_hi = 1
; // arg0 * 2
; // arg0 * 3
; cycles = usecs * 24
; end_lo = time_lo + cycles
; if (end_lo >= time_lo)


;     end_hi = 0
; end_hi += time_hi
; do {
;     (time_hi, time_lo) = cnt64_read()
; } while (end_hi > time_hi ||
;         (end_hi == time_hi &&
;             end_lo > time_lo))







; return





















































































; int r_uart_putc(char c);


; ptr4 = 0x00011d88
; ret = -1
; var4 = *ptr4
; if (var4 != 0)
;     return ret
; c = (char) c

; ptr4 = 0x00011f7c
; var4 = *ptr4
; if (var4 != 0)
;     return ret

; ptr4 = 0x01f0287c [R_UART_USR]
; while ((*ptr4 & BIT(1)) == 0)
;     /* spin */




; ret = 0
; ptr4 = 0x01f02800 [R_UART_THR]
; *ptr4 = c
; return ret


; int r_uart_gets(char *buf);

; ret = -1
; ptr4 = 0x00011d88
; var4 = *ptr4
; if (var4 != 0)
;     return ret


; ptr4 = 0x00011f7c
; var4 = *ptr4
; if (var4 != 0)
;     return ret

; ret = var4 [ret = 0]

; ptr5 = 0x01f02884 [R_UART_RFL]
; for (ptr4 = 0x01f02800; var6; var6 = *ptr5)
;     ptr6 = &buf[ret]
;     var7 = *ptr4
;     ret += 1
;     *(char *)ptr6 = r7



; DOES NOT NULL TERMINATE
; return ret


; int r_uart_puts(char *str)

; ptr2 = str


; ptr3 = 0x00011d88

; var3 = *ptr3
; if (var3 != 0)
;     return ret
; DS ret = -1

; ptr3 = 0x00011f7c
; var3 = *ptr3
; if (var3 != 0)


;     return ret

; while ((ret = *(char *)ptr2) != '\0')
;     if (ret == '\n')
;         r_uart_putc('\r')


;     r_uart_putc(*(char *)ptr2)
;     ptr2 += 1






; return ret

















; msg = 0x00011303 "uart buadrate change from [%d] to [%d]"




















































































; msg = 0x0001132b "uart source clock change request"




















; msg = 0x0001134d "uart buadrate change done"















; void delay(u32 cycles);
; while (cycles-- != 0)
;     /* spin */

; cycles += 1
; return























































































































































; msg = 0x00011368 "%s :"










; msg = 0x0001136e " 0x%8x :"





; msg = 0x00011378 "%8x"

















; int strlen(char *str);
; end = str
; do {

;     end += 1
; } while ((c = *(char *)end) != 0)
; end -= 1
; return end - str


; char *strcpy(char *s1, char *s2);
; off = 0
; do {p2 = s2 + off
;     p1 = s1 + off
;     c = *p2
;     *p1 = c

;     off += 1
; } while (c != '\0')
; return s1

















































































































































































































; msg = 0x0001137d "freq   :%d"





; msg = 0x00011389 "voltage:%d"





; msg = 0x00011395 "axi_div:%d"














































; msg = 0x000113a1 "dvfs try to increase voltage failed"



















; msg = 0x000113c6 "current voltage != target voltage"



















































; msg = 0x000113e9 "dvfs try to decrease voltage failed"


















; msg = 0x0001140e "DVFS succeed, freq = %u, voltage = %u, axi_div = %u"
















































































































; msg = 0x00011443 "fn:%x,arg:%x"

































; msg = 0x00011451 "standby power check enable:0x%x, regs:0x%x, sys_power:%d"





















; void dram_set_crc_params(u32 a, u32 b, u32 c);


; ptr = 0x000121cc
; *ptr = a

; ptr = 0x00011db0
; *ptr = b

; ptr = 0x00011db4
; return
; DS *ptr = c

; u32 get_0x121cc(void);

; ptr = 0x000121cc
; return *ptr












; msg = 0x0001148b "crc begin..."








; msg = 0x00011499 "src:%x len:%x"
















; msg = 0x000114a8 "crc finish..."




























; msg = 0x000114b7 "stack free:%dbyte"





















; u32 disable_interrupts(void);

; mask = 0xfffffff9
; addr = SPR_SR

; old = read_spr(addr)
; new = old & mask
; write_spr(addr, new)

; return old


; void restore_interrupts(u32 value);
; addr = SPR_SR
; write_spr(addr, value)
; return void


; __noreturn void exit(void);




; printf(8, msg)
; msg = 0x000114ca "system exit"
; loop




















; ptr = 0x00011dd4 <array of char* exc types>





; msg = 0x000114d7 "exception [%x, %s] coming, [epc = %x]"




; msg = 0x000114fe "register list:"





; msg = 0x0001150e "register%x: %x"










; msg = 0x0001151e "cpu abort enter..."

; loop












































; u32 get_0x121e4(void);

; ptr3 = 0x000121e4
; ret = *ptr3
; return ret










































; msg = 0x00011618 "setup timer server succeeded"



































; msg = 0x00011636 "debugger system ok"





; msg = 0x0001164a "rsb driver ok"





; msg = 0x00011659 "pmu driver ok"





; msg = 0x00011668 "hwspinlock driver ok"





; msg = 0x0001167e "hwmsgbox driver ok"





; msg = 0x00011692 "message manager ok"





; msg = 0x000116a6 "cpucfg driver ok"





; msg = 0x000116b8 "timer driver ok"





; msg = 0x000116c9 "dvfs service driver ok"





; msg = 0x000116e1 "standby service ok"





; msg = 0x000116f5 "time ticks ok"



; msg = 0x00011704 "watchdog ok"








; msg = 0x00011711 "allocate message for init fb failed"





; msg = 0x00011736 "feedback startup result [%d]"















; msg = 0x00011754 "v0.1.54"













; msg = 0x0001175c "startup feedback ok"




; msg = 0x00011771 "ar100 firmware version : %d"







; msg = 0x0001178e "daemon service setup..."

































































; msg = 0x00010924 "arisc_para_get_message_pool_info"



; msg = 0x000117a7 "%s: %x %x"











; ptr = 0x000124f4
; return *(ptr + 0x10)














; msg = 0x000117b2 "" <whitespace>






























; ret = 0
; return ret

; int putc(char c);
; ret = 0



; r_uart_putc((char) c)



; return 0


; int gets(char *buf);




; return r_uart_gets(buf)


; int puts(char *str);

; r_uart_puts(str)



; return 0


; int printf(u32 mask, char *fmtstr, ...);



; ptr2 = 0x00011e14

; ret = *ptr2
; var2 = 240
; ret += 1

; ret = var2 >> ret




; ret &= mask

; if (ret == 0)
;     return ret
; fmtstr = arg1
; ret = disable_interrupts()

; ptr2 = 0x00011e18
; var22 = ret
; var2 = *ptr2

; if (var2 != 0) {

;     ret = get_0x121e4()
;     var2 = 91

























































; }

; str = 0x0001266c
; while ((fmt = *fmtstr) != 0) {
;     if (fmt == '%') {

















































































;     } else {
;         *str = fmt
;         str += 1
;         fmtstr += 1
;     }


; }














; puts(0x0001266c)

; write_sr(var22)

; ptr3 = 0x0001266c

; ret = str - ptr3








; return ret


; int set_debug_mask(u32 mask);



; debug_mask_ptr = 0x00011e14



; new_mask = mask
; old_mask = *debug_mask_ptr
; msg = 0x000117c3 ["debug_mask from %d to %d"]


; printf(8, msg, old_mask, new_mask)

; *debug_mask_ptr = new_mask

; ret = 0


; return ret




; ptr = 0x000121f4
; var4 = *ptr
; if (arg0 < var4)
;     return 0
; ret = 0

; ptr = 0x000121f8
; var5 = *ptr
; if (arg0 < var5)
;     return 1


; ret = 0
; return ret



















; msg = 0x000117dd "%s: message pool addr=%x, size=%x"







































































; msg = 0x00011800 "message [%x] alloc from cache"





; msg = 0x0001181f "message_cache num:%x"




























; msg = 0x00011835 "message alloc from pool"
















; msg = 0x0001184e "allocate message invalid, add:%p"































; msg = 0x00011870 "free invalid message"














; msg = 0x00011886 "message [%x] insert to message_cache"





; msg = 0x000118ac "message_cache number:%x"















































; msg = 0x000118c5 "MESSAGE FROM AC327"














; msg = 0x000118d9 "attr:%x"





























































; msg = 0x000118e2 "cpux dvfs request"





; msg = 0x000118f5 "esstandby enter request"
























; msg = 0x0001190e "copy esstandby code"


; rtc_set_pwrstate(0xf3f30000)








; msg = 0x00011923 "set ir paras request"







; msg = 0x00011939 "standby info request"







; msg = 0x0001194f "disable axp irq request"






; msg = 0x00011968 "enable axp irq request"









; msg = 0x00011980 "axp get chip id request"





; msg = 0x00011999 "pmu set paras request"





; msg = 0x000119b0 "read pmu register request"







; msg = 0x000119cb "write pmu register request"







; msg = 0x000119e7 "rsb bits ops request"







; msg = 0x000119fd "set debug level request"







; msg = 0x00011a16 "set uart baudrate request"





; msg = 0x00011a31 "set dram crc paras request"







; msg = 0x00011a4d "loopback message request"







; msg = 0x00011a67 "invalid message type [%x]"











































































































; msg = 0x00011a82 "allocate notifier failed"






















































; int ???(??? *arg0, ??? arg1, ??? arg2);




; var16 = arg1

; var14 = arg2
; ptr = *arg0
; while (ptr != NULL) {
;     funcptr = *(ptr + 4)
;     (*funcptr)(arg1, arg2)

;     ptr = *(ptr + 8)


; }

; ret = 0



; return ret


; void icache_flush(void);






; step = 16
; addr = 0
; limit = 4096
; do {
;     <invalidate icache at addr>
; } while ((addr += step) != limit)




















































































































































































































































































































































































































































































































; rtc_set_pwrstate(0xf3f31000)










; rtc_set_pwrstate(0xf3f31001)




























; msg = 0x00010114 "%x enter"





; rtc_set_pwrstate(0xf3f32000)

; rtc_set_pwrstate(0xf3f33001)




















; rtc_set_pwrstate(0xf3f33002)





; rtc_set_pwrstate(0xf3f33003)




; rtc_set_pwrstate(0xf3f33004)



















; rtc_set_pwrstate(0xf3f33005)







; rtc_set_pwrstate(0xf3f33006)









































; rtc_set_pwrstate(0xf3f33007)






; rtc_set_pwrstate(0xf3f33008)




; rtc_set_pwrstate(0xf3f33009)


























































































































































































































































































































































































































































































































































































































































































; rtc_set_pwrstate(0xf3f3300a)





































; rtc_set_pwrstate(0xf3f3300b)




















































































; rtc_set_pwrstate(0xf3f3300c)



; rtc_set_pwrstate(0xf3f34000)












; msg = 0x0001011e "estif"















































; msg = 0x00010125 "wait wakeup event coming"




; rtc_set_pwrstate(0xf3f35000)






























































; msg = 0x0001013f "pin wakeup detect"






















; msg = 0x00010152 "cir wakeup detect"






















































; msg = 0x00010165 "USB EHCI0 wakeup"







; msg = 0x00010177 "USB otg wakeup detect"














; msg = 0x0001018e "USB wakeup detect"



































; rtc_set_pwrstate(0xf3f36000)






; rtc_set_pwrstate(0xf3f37001)
































































; rtc_set_pwrstate(0xf3f37002)






































; rtc_set_pwrstate(0xf3f37003)



































































































































































































































































































































































































































; rtc_set_pwrstate(0xf3f37004)




; rtc_set_pwrstate(0xf3f37005)






































; rtc_set_pwrstate(0xf3f3900f)




; msg = 0x000101a1 "dram crc error..."




; rtc_set_pwrstate(0xf3f37006)







; rtc_set_pwrstate(0xf3f37007)



















; rtc_set_pwrstate(0xf3f37008)









; rtc_set_pwrstate(0xf3f37009)





; rtc_set_pwrstate(0xf3f3700a)





; rtc_set_pwrstate(0xf3f3700b)























; msg = 0x000101b4 "esstandby ignore message [%x, %x]"




















; rtc_set_pwrstate(0xf3f3700c)





; rtc_set_pwrstate(0xf3f3700d)


; rtc_set_pwrstate(0xf3f38000)










; msg = 0x000101d7 "%x return"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































